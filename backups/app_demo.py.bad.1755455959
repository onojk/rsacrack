#!/usr/bin/env python3
from pathlib import Path
from time import perf_counter
from typing import Any

from flask import Flask, request, send_from_directory, jsonify

from coil_classifier import (
    coil_classify,
    footprint_for_semiprime,
    geometry_signature,
    invariant_signature,
)

# --- Paths -------------------------------------------------------------------
APP_DIR = Path(__file__).parent.resolve()
WEB_DIR = APP_DIR / "web"
CACHE_DIR = APP_DIR / "cache"
WEB_DIR.mkdir(exist_ok=True)
CACHE_DIR.mkdir(exist_ok=True)

# --- Flask app ---------------------------------------------------------------
app = Flask(__name__, static_folder=str(WEB_DIR))


# --- Safe parsers (robust against bad UI values like "[object HTMLInputElement]") ---
def _to_int(x: Any, default: int) -> int:
    try:
        s = str(x)
        if not s or s.lower() == "none":
            return default
        return int(s)
    except Exception:
        return default


def _to_float(x: Any, default: float) -> float:
    try:
        s = str(x)
        if not s or s.lower() == "none" or s.startswith("[object "):
            return default
        return float(s)
    except Exception:
        return default


# --- Tiny helpers ------------------------------------------------------------
def _is_prime(n: int) -> bool:
    if n < 2:
        return False
    if n % 2 == 0:
        return n == 2
    i = 3
    while i * i <= n:
        if n % i == 0:
            return False
        i += 2
    return True


def _trial_semiprime(n: int):
    """Small, fast trial division to detect semiprimes."""
    if n % 2 == 0:
        p, q = 2, n // 2
        return (p, q) if _is_prime(q) else None
    i = 3
    # keep this sane — this is just for quick sanity, not full factoring
    while i * i <= n and i <= 10_000_000:
        if n % i == 0:
            p, q = i, n // i
            return (p, q) if _is_prime(p) and _is_prime(q) else None
        i += 2
    return None


# --- Web UI ------------------------------------------------------------------
@app.get("/")
def index():
    return send_from_directory(WEB_DIR, "index.html")


@app.get("/web/<path:filename>")
def web_static(filename: str):
    # Serve other assets (js, css, images)
    return send_from_directory(WEB_DIR, filename)


@app.get("/healthz")
def healthz():
    return "ok"


# --- API: classify -----------------------------------------------------------
@app.get("/api/classify")
def api_classify():
    # required
    n = _to_int(request.args.get("n", "0"), 0)
    if n <= 0:
        return jsonify(error="bad n"), 400

    # optional render params — default to current UI defaults
    r0 = _to_float(request.args.get("r0", 1.0), 1.0)
    alpha = _to_float(request.args.get("alpha", 0.0125), 0.0125)
    beta = _to_float(request.args.get("beta", 0.005), 0.005)
    L = _to_float(request.args.get("L", 360.0), 360.0)

    klass = coil_classify(n)  # "prime" | "semiprime" | "other"
    out = {"n": n, "class": klass}

    if klass == "semiprime":
        # Never 500 here — if footprint fails, return error detail but keep 200
        try:
            fp = footprint_for_semiprime(n, r0, alpha, beta, L)
        except Exception as e:
            out.update(
                {
                    "primes": [],
                    "normalized": {},
                    "balance": None,
                    "bit_gap": None,
                    "sig_geom": None,
                    "sig_invariant": None,
                    "footprint_error": str(e),
                }
            )
        else:
            # Expect fp to include: primes, normalized{f1,f2,f3}, balance, bit_gap
            out.update(fp)
            # Add signatures if available
            try:
                out["sig_geom"] = geometry_signature(n)
            except Exception:
                pass
            try:
                out["sig_invariant"] = invariant_signature(n)
            except Exception:
                pass

    return jsonify(out)


# --- API: factor -------------------------------------------------------------
@app.get("/api/factor")
def api_factor():
    n = _to_int(request.args.get("n", "0"), 0)
    if n <= 0:
        return jsonify(error="bad n"), 400

    t0 = perf_counter()

    if _is_prime(n):
        return jsonify(
            {"class_": "prime", "n": n, "ms": (perf_counter() - t0) * 1000.0}
        )

    pair = _trial_semiprime(n)
    if pair:
        p, q = pair
        return jsonify(
            {
                "class": "semiprime",
                "n": n,
                "factors": [int(p), int(q)],
                "method": "trial",
                "ms": (perf_counter() - t0) * 1000.0,
            }
        )

    return jsonify(
        {
            "class": "other",
            "n": n,
            "factors": [],
            "method": "trial",
            "ms": (perf_counter() - t0) * 1000.0,
        }
    )


# --- Gunicorn safety guard (app exists even if imports above were reordered) -
try:
    app  # type: ignore  # noqa: F401
except NameError:  # pragma: no cover
    app = Flask(__name__, static_folder=str(WEB_DIR))

# --- Dev run -----------------------------------------------------------------
# --- flexible entrypoint for dev runs ---
if __name__ == "__main__":
    import os, argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("--host", default=os.environ.get("HOST", "127.0.0.1"))
    parser.add_argument("--port", type=int, default=int(os.environ.get("PORT", "8001")))
    parser.add_argument("--debug", action="store_true")
    args = parser.parse_args()
    app.run(host=args.host, port=args.port, debug=args.debug)

# --- annotate /api/classify with a PRIME / NOT prime line ---
try:
    import json
    from flask import request
    @app.after_request
    def _annotate_prime_status(resp):
        try:
            if request.path == "/api/classify" and resp.mimetype.startswith("application/json"):
                data = resp.get_json(silent=True)
                if isinstance(data, dict) and "prime_status" not in data:
                    cls = data.get("class")
                    n_val = data.get("n")
                    if cls == "prime":
                        data["prime_status"] = f"{n_val} is PRIME"
                    else:
                        # covers semiprime, composite, other
                        data["prime_status"] = f"{n_val} is NOT prime" + (f" ({cls})" if isinstance(cls, str) else "")
                                        # Flag JS safety (2^53-1) and avoid misleading floaty "n"
                    try:
                        s = str(display_n)
                        s_digits = s.lstrip("+")
                        js_safe = s_digits.isdigit() and len(s_digits) <= 15 and int(s_digits) <= 9007199254740991
                        data["n_js_safe"] = bool(js_safe)
                        if not js_safe:
                            # keep canonical n_str; hide numeric n so clients don't see 1e+40
                            data["n"] = None
                    except Exception:
                        pass
                    resp.set_data(json.dumps(data))
        except Exception:
            # never break the response
            pass
        return resp
except Exception:
    pass
# ----------------------------------------------------------------
# --- normalize big integer display and prime_status (runs after /api/classify) ---
try:
    import json
    from flask import request
# --- single after_request for /api/classify: n_str + prime_status + n_js_safe ---
try:
    import json
    from flask import request
    @app.after_request
def _normalize_n_and_status(resp):
        try:
            if request.path == "/api/classify" and resp.mimetype and resp.mimetype.startswith("application/json"):
                data = resp.get_json(silent=True)
                if isinstance(data, dict):
                    # always keep the original user input as a string (avoid 1e+40 surprises)
                    display_n = (request.args.get("n") or data.get("n_str") or
                                 (str(data.get("n")) if data.get("n") is not None else "") )
                    data["n_str"] = display_n

                    # human-friendly PRIME / NOT prime
                    cls = data.get("class")
                    if cls == "prime":
                        data["prime_status"] = f"{display_n} is PRIME"
                    else:
                        data["prime_status"] = f"{display_n} is NOT prime" + (f" ({cls})" if isinstance(cls, str) and cls else "")

                    # JS safety: true if <= 2^53-1 and all digits
                    try:
                        s = str(display_n)
                        s_digits = s.lstrip("+")
                        js_safe = s_digits.isdigit() and len(s_digits) <= 15 and int(s_digits) <= 9007199254740991
                        data["n_js_safe"] = bool(js_safe)
                        if not js_safe:
                            # hide numeric n so clients don't see 1e+40; keep n_str canonical
                            data["n"] = None
                    except Exception:
                        data["n_js_safe"] = None

                    resp.set_data(json.dumps(data))
        except Exception:
            # never break the response
            pass
        return resp
except Exception:
    pass
# -------------------------------------------------------------------------------

except Exception:
    pass
# -------------------------------------------------------------------------------
