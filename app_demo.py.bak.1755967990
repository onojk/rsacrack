from nextprime_utils import next_prime, is_probable_prime
import time
#!/usr/bin/env python3
import os, json, time, subprocess
from flask import Flask, request, jsonify, send_file, render_template_string, abort
from tangent_prime_test import classify, tangent_equal_split_info, tangent_prime_test_split_info

app = Flask(__name__)
BASE_DIR = os.path.abspath(os.path.dirname(__file__))
CACHE_DIR = os.path.join(BASE_DIR, "cache")
os.makedirs(CACHE_DIR, exist_ok=True)

HTML = """<!doctype html><meta name="viewport" content="width=device-width, initial-scale=1">
<title>RSAcrack · Coil & Tangent Tools</title>
<style>
 body{font:16px/1.4 system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;padding:24px;max-width:920px;margin:auto}
 h1{margin:0 0 12px}
 .card{border:1px solid #ddd;border-radius:12px;padding:16px;margin:12px 0}
 label{display:block;margin:8px 0 4px}
 input[type=number],input[type=text]{width:100%;max-width:420px;padding:8px}
 button{padding:10px 14px;border-radius:10px;border:1px solid #333;background:#111;color:#fff}
 .muted{color:#666}
</style>
<h1>RSAcrack · Coil & Tangent Tools</h1>
<div class="card">
  <h2>Factor / Classify</h2>
  <form onsubmit="runFactor(event)">
    <label>n</label>
    <input id="n" type="text" placeholder="enter integer (fits in RAM/time)"/>
    <button>Run</button>
  </form>
  <pre id="factout" class="muted">Result will appear here…</pre>
</div>
<div class="card">
  <h2>Adaptive Coil Scan</h2>
  <form onsubmit="startCoil(event)">
    <label>Start</label><input id="start" type="number" value="2">
    <label>Stop</label><input id="stop" type="number" value="100000">
    <label>Mode</label><input id="mode" type="text" value="thin">
    <label>Diag period (sampled mode)</label><input id="diag" type="number" value="1000">
    <label>Shard size (0 = single file)</label><input id="shard" type="number" value="0">
    <button>Start scan</button>
  </form>
  <div id="job" class="muted"></div>
  <pre id="progress" class="muted">Progress appears here…</pre>
</div>
<script>
async function runFactor(e){
  e.preventDefault();
  const n = document.getElementById('n').value.trim();
  const r = await fetch('/api/factor?n='+encodeURIComponent(n));
  const j = await r.json();
  document.getElementById('factout').textContent = JSON.stringify(j,null,2);
}
async function startCoil(e){
  e.preventDefault();
  const payload = {
    start: parseInt(document.getElementById('start').value),
    stop: parseInt(document.getElementById('stop').value),
    mode: document.getElementById('mode').value,
    diag_period: parseInt(document.getElementById('diag').value),
    shard_size: parseInt(document.getElementById('shard').value),
  };
  let r = await fetch('/api/coil/start',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify(payload)});
  const j = await r.json();
  document.getElementById('job').innerHTML = 'Job ID: <b>'+j.job_id+'</b> — <a href="/api/coil/download?id='+j.job_id+'">download</a>';
  poll(j.job_id);
}
async function poll(id){
  const area = document.getElementById('progress');
  while(true){
    const r = await fetch('/api/coil/progress?id='+encodeURIComponent(id));
    const j = await r.json();
    area.textContent = JSON.stringify(j,null,2);
    if(j.state!=='running') break;
    await new Promise(res=>setTimeout(res,1500));
  }
}
</script>"""

@app.get("/")
def home():
    return render_template_string(HTML)

@app.get("/api/factor")
def api_factor():
    n_raw = request.args.get("n","").strip()
    if not n_raw.isdigit(): return jsonify(error="Provide n as a non-negative integer string"), 400
    n = int(n_raw)
    kind, cnt = classify(n)
    return jsonify(n=n, classification=kind,
                   factors=dict(cnt),
                   equal_split=tangent_equal_split_info(n),
                   prime_test=tangent_prime_test_split_info(n))

def _start_subprocess(cmd, log_path):
    with open(log_path, "ab", buffering=0) as log:
        return subprocess.Popen(cmd, stdout=log, stderr=log, bufsize=0)

@app.post("/api/coil/start")
def api_coil_start():
    data = request.get_json(force=True) or {}
    start = int(data.get("start", 2))
    stop = int(data.get("stop", 100000))
    mode = str(data.get("mode", "thin"))
    diag = int(data.get("diag_period", 1000))
    shard = int(data.get("shard_size", 0))
    if start < 2 or stop < start: return jsonify(error="Invalid range"), 400

    job_id = f"{int(time.time())}-{os.getpid()}-{start}-{stop}"
    out_template = os.path.join(CACHE_DIR, f"{job_id}.n"+"{lo:06d}-{hi:06d}.csv.gz")
    out_single = os.path.join(CACHE_DIR, f"{job_id}.csv.gz")
    log_path = os.path.join(CACHE_DIR, f"{job_id}.log")
    meta_path = os.path.join(CACHE_DIR, f"{job_id}.json")

    cmd = [ "python3", "-u", os.path.join(os.path.dirname(__file__), "coil_scanner.py"),
            "--start", str(start), "--stop", str(stop),
            "--mode", mode, "--diag-period", str(diag),
            "--progress-every", "500000" ]
    if shard > 0:
        cmd += ["--shard-size", str(shard), "--out-template", out_template]
        out_path = out_template.replace("{lo:06d}-{hi:06d}", "??????-??????")
    else:
        cmd += ["--out", out_single]
        out_path = out_single

    proc = _start_subprocess(cmd, log_path)
    meta = {"job_id": job_id, "pid": proc.pid, "cmd": cmd, "log": log_path, "out": out_path, "state":"running"}
    with open(meta_path, "w") as f: json.dump(meta, f)
    return jsonify(job_id=job_id, out=out_path)

@app.get("/api/coil/progress")
def api_coil_progress():
    job_id = request.args.get("id","")
    meta_path = os.path.join(CACHE_DIR, f"{job_id}.json")
    if not os.path.exists(meta_path): return jsonify(error="unknown job"), 404
    meta = json.load(open(meta_path))

    try:
        os.kill(meta["pid"], 0); state = "running"
    except ProcessLookupError:
        state = "finished"

    last_n = None
    if os.path.exists(meta["log"]):
        try:
            with open(meta["log"], "rb") as f:
                f.seek(max(0, os.path.getsize(meta["log"]) - 64000))
                tail = f.read().decode("utf-8", "ignore").splitlines()[-300:]
            for line in reversed(tail):
                if "[progress]" in line and "n=" in line:
                    try:
                        last_n = int(line.split("n=")[-1].split()[0]); break
                    except Exception: pass
        except Exception: pass

    meta["state"] = state; meta["last_n"] = last_n
    return jsonify(meta)

@app.get("/api/coil/download")
def api_coil_download():
    job_id = request.args.get("id","")
    single = os.path.join(CACHE_DIR, f"{job_id}.csv.gz")
    if os.path.exists(single):
        return send_file(single, as_attachment=True, download_name=f"{job_id}.csv.gz")
    prefix = os.path.join(CACHE_DIR, f"{job_id}.n")
    shards = sorted([p for p in os.listdir(CACHE_DIR) if p.startswith(os.path.basename(prefix)) and p.endswith(".csv.gz")])
    if not shards: return jsonify(error="output not ready"), 404
    return jsonify(shards=[f"/cache/{name}" for name in shards])

@app.get("/cache/<path:name>")
def get_cache(name):
    full = os.path.join(CACHE_DIR, name)
    if not os.path.abspath(full).startswith(CACHE_DIR) or not os.path.exists(full): abort(404)
    return send_file(full, as_attachment=True)

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=int(os.getenv("PORT","8080")), debug=False)

# --- Next prime API (wheel + Miller–Rabin) ---
from nextprime import next_prime
    start_s = request.args.get("start","0")
    try:
        start = int(start_s)
        if start < 0: raise ValueError
    except Exception:
        return jsonify({"error":"Provide 'start' as a non-negative integer"}), 400
    t0 = time.perf_counter()
    p,iters = next_prime(start, return_iters=True)
    ms = (time.perf_counter()-t0)*1000
    return jsonify({"start":start,"prime":p,"iters":iters,"ms":round(ms,3)})

    n_s = request.args.get("n","0")
    try:
        n = int(n_s)
        if n < 0: raise ValueError
    except Exception:
        return jsonify({"error":"Provide 'n' as a non-negative integer"}), 400
    t0 = time.perf_counter()
    isp = is_probable_prime(n)
    ms = (time.perf_counter()-t0)*1000
    return jsonify({"n":n,"prime":bool(isp),"ms":round(ms,3)})

# --- Prime utilities API ---
from nextprime_utils import next_prime, is_probable_prime

@app.get("/api/next_prime")
def api_next_prime():
    start_s = request.args.get("start","0")
    try:
        start = int(start_s)
        if start < 0: 
            raise ValueError
    except Exception:
        return jsonify({"error":"Provide 'start' as a non-negative integer"}), 400
    t0 = time.perf_counter()
    p,iters = next_prime(start, return_iters=True)
    ms = (time.perf_counter()-t0)*1000
    return jsonify({"start":start,"prime":p,"iters":iters,"ms":round(ms,3)})

@app.get("/api/is_prime")
def api_is_prime():
    n_s = request.args.get("n","0")
    try:
        n = int(n_s)
        if n < 0: 
            raise ValueError
    except Exception:
        return jsonify({"error":"Provide 'n' as a non-negative integer"}), 400
    t0 = time.perf_counter()
    isp = is_probable_prime(n)
    ms = (time.perf_counter()-t0)*1000
    return jsonify({"n":n,"prime":bool(isp),"ms":round(ms,3)})

@app.get("/api/next_primes")
def api_next_primes():
    start_s = request.args.get("start","0")
    count_s = request.args.get("count","10")
    try:
        start = int(start_s); count = int(count_s)
        if start < 0 or not (1 <= count <= 10000):
            raise ValueError
    except Exception:
        return jsonify({"error":"Provide 'start' >= 0 and 1<= 'count' <= 10000"}), 400
    t0 = time.perf_counter()
    primes = []
    n = start
    while len(primes) < count:
        p, _ = next_prime(n, return_iters=True)
        primes.append(p)
        n = p + 1
    ms = (time.perf_counter()-t0)*1000
    return jsonify({"start": start, "count": count, "primes": primes, "ms": round(ms,3)})

@app.get("/api/prev_prime")
def api_prev_prime():
    n_s = request.args.get("n","0")
    try:
        n = int(n_s)
        if n <= 2: 
            return jsonify({"error":"No prime < 2"}), 400
    except Exception:
        return jsonify({"error":"Provide 'n' as an integer > 2"}), 400
    t0 = time.perf_counter()
    # step down using same 6k±1 wheel
    k = max(3, n-1)
    if k % 2 == 0: k -= 1
    step = 2
    while k >= 3:
        if is_probable_prime(k):
            ms = (time.perf_counter()-t0)*1000
            return jsonify({"n": n, "prime": k, "ms": round(ms,3)})
        k -= step
        step = 6 - step
    return jsonify({"n": n, "prime": 2, "ms": round((time.perf_counter()-t0)*1000,3)})

@app.get("/api/random_prime")
def api_random_prime():
    bits_s = request.args.get("bits","32")
    try:
        bits = int(bits_s)
        if not (2 <= bits <= 4096):
            raise ValueError
    except Exception:
        return jsonify({"error":"Provide 'bits' between 2 and 4096"}), 400
    t0 = time.perf_counter()
    from nextprime_utils import random_prime
    p = random_prime(bits)
    ms = (time.perf_counter()-t0)*1000
    return jsonify({"bits":bits,"prime":p,"ms":round(ms,3)})
