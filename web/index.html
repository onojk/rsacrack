<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";

const ui = {
  n:      document.getElementById('n'),
  r0:     document.getElementById('r0'),
  alpha:  document.getElementById('alpha'),
  beta:   document.getElementById('beta'),
  L:      document.getElementById('L'),
  go:     document.getElementById('go'),
  out:    document.getElementById('out')
};

// Add a tiny “factor too” toggle and a copy button (non-destructive: appended)
const bar = ui.go.parentElement;
const chk = document.createElement('label');
chk.style.marginLeft = "8px";
chk.style.fontSize = "12px";
chk.innerHTML = `<input id="factorToo" type="checkbox" checked style="vertical-align:middle;margin-right:6px;">Factor too`;
bar.appendChild(chk);

const copyBtn = document.createElement('button');
copyBtn.textContent = 'Copy JSON';
copyBtn.id = 'copyBtn';
copyBtn.style.marginLeft = '8px';
bar.appendChild(copyBtn);

const factorToo = () => document.getElementById('factorToo').checked;

// ------- three.js scene -------
const canvas = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0b0f16);
const camera = new THREE.PerspectiveCamera(60, 2, 0.01, 5000);
camera.position.set(0, 0, 18);
const light = new THREE.DirectionalLight(0xffffff, 1.0);
light.position.set(5,10,8); scene.add(light);

let points = null;

function makeCoilPoints(N, r0, alpha, beta, L) {
  const aN = new Float32Array(N);
  for (let i=0;i<N;i++) aN[i] = i+1;
  const geom = new THREE.BufferGeometry();
  geom.setAttribute("aN", new THREE.BufferAttribute(aN, 1));
  const vsh = `
    precision highp float;
    attribute float aN;
    uniform float r0, alpha, beta, L;
    varying float vN;
    void main(){
      float n = aN;
      float r = r0 + alpha * n;
      float theta = 6.283185307179586 * n / L; // 2*pi*n/L
      vec3 pos = vec3(r*cos(theta), r*sin(theta), beta*n);
      vec4 mv = modelViewMatrix * vec4(pos,1.0);
      gl_Position = projectionMatrix * mv;
      gl_PointSize = 3.0 / -mv.z * 250.0;
      vN = n;
    }`;
  const fsh = `
    precision highp float;
    varying float vN;
    uniform float p, q, n;
    void main(){
      vec3 col = vec3(0.25,0.35,0.8);                   // base
      if (abs(vN-1.0)<0.5) col = vec3(0.95,0.9,0.2);    // 1
      if (abs(vN-p)<0.5) col = vec3(0.2,0.9,0.6);       // p
      if (abs(vN-q)<0.5) col = vec3(0.9,0.3,0.3);       // q
      if (abs(vN-n)<0.5) col = vec3(0.95,0.6,0.2);      // n
      gl_FragColor = vec4(col, 1.0);
    }`;
  const mat = new THREE.ShaderMaterial({
    vertexShader: vsh, fragmentShader: fsh,
    uniforms: { r0:{value:r0}, alpha:{value:alpha}, beta:{value:beta}, L:{value:L},
                p:{value:0}, q:{value:0}, n:{value:0} }
  });
  const pts = new THREE.Points(geom, mat);
  scene.add(pts);
  return pts;
}

function resizeRendererToDisplaySize() {
  const w = window.innerWidth, h = window.innerHeight;
  if (canvas.width !== w || canvas.height !== h) {
    renderer.setSize(w, h, false);
    camera.aspect = w/h; camera.updateProjectionMatrix();
  }
}

function renderLoop(){
  resizeRendererToDisplaySize();
  scene.rotation.z += 0.0015;
  renderer.render(scene, camera);
  requestAnimationFrame(renderLoop);
}
renderLoop();

// ------- helpers -------
function num(el) { return Number(el.value); }
function pretty(obj){ return JSON.stringify(obj, null, 2); }

async function classifyAndRender() {
  const n = num(ui.n);
  const r0 = num(ui.r0), alpha = num(ui.alpha), beta = num(ui.beta), L = num(ui.L);

  // parallel requests: classify + (optional) factor
  const qClass = fetch(`/api/classify?n=${n}&r0=${r0}&alpha=${alpha}&beta=${beta}&L=${L}`)
                    .then(r=>r.json());
  const qFactor = factorToo()
      ? fetch(`/api/factor?n=${n}`).then(r=>r.json()).catch(()=>({error:"factor failed"}))
      : Promise.resolve(null);

  const [cls, fac] = await Promise.all([qClass, qFactor]);

  // merge a compact view for the sidebar
  const merged = { ...cls };
  if (fac) merged.factor = {
    factors: fac.factors,
    method: fac.method,
    ms: fac.ms
  };

  ui.out.textContent = pretty(merged);

  // draw points and color labels
  if (points) scene.remove(points);
  const N = Math.min(n, 20000);
  points = makeCoilPoints(N, r0, alpha, beta, L);
  points.material.uniforms.n.value = n;

  if (cls.class === "semiprime" && Array.isArray(cls.primes)) {
    points.material.uniforms.p.value = cls.primes[0];
    points.material.uniforms.q.value = cls.primes[1];
  } else if (fac && fac.factors && fac.factors.length === 2) {
    // If classifier didn’t return primes but factorizer did, still highlight them.
    const [p,q] = fac.factors[0] <= fac.factors[1] ? fac.factors : [fac.factors[1], fac.factors[0]];
    points.material.uniforms.p.value = p;
    points.material.uniforms.q.value = q;
  } else {
    points.material.uniforms.p.value = 0;
    points.material.uniforms.q.value = 0;
  }
}

// wire buttons
ui.go.addEventListener('click', classifyAndRender);
document.getElementById('copyBtn').addEventListener('click', async () => {
  try { await navigator.clipboard.writeText(ui.out.textContent); }
  catch {}
});

// first render
classifyAndRender();
</script>
